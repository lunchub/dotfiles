[[plugins]]
repo = 'junegunn/fzf.vim'
hook_add = '''
  nnoremap    [fzf]   <Nop>
  nmap      , [fzf]

  nnoremap <silent> <C-f> :<C-u>CustomFZF<CR>
  nnoremap <silent> [fzf]b :<C-u>FZFBuffers<CR>
  nnoremap <silent> [fzf]m :<C-u>FZFMru<CR>
  nnoremap <silent> [fzf]gg :<C-u>Agg<CR>
  nnoremap <silent> [fzf]gk :<C-u>Agk<CR>
  nnoremap <silent> [fzf]gc :<C-u>Agc<CR>

  function! s:common_handler(lines)
    if len(a:lines) < 2 | return | endif

    let cmd = get({
      \ 'ctrl-s': 'split',
      \ 'ctrl-v': 'vertical split',
      \ 'ctrl-n': 'tabe'
    \ }, a:lines[0], 'e')

    let list = map(a:lines[1:], '{"filename": v:val}')

    if a:lines[0] == 'ctrl-n'
      let first = list[0]
      execute cmd first.filename

      if len(list) > 1
        call setqflist(list)
        copen
        wincmd p
      endif
    else
      for file in list
        execute cmd file.filename
      endfor
    endif
  endfunction

  command! -nargs=* CustomFZF call fzf#run({
  \   'source': 'git ls-files -oc --exclude-standard',
  \   'sink*':    function('<sid>common_handler'),
  \   'options': '-m -x --reverse --expect=enter,ctrl-s,ctrl-v,ctrl-n',
  \   'down':    '50%'
  \ })

  command! FZFBuffers call fzf#run(fzf#wrap({
  \   'source': map(range(1, bufnr('$')), 'bufname(v:val)'),
  \   'sink*':    function('<sid>common_handler'),
  \   'options': '-m -x --reverse --expect=enter,ctrl-s,ctrl-v,ctrl-n',
  \   'down':    '50%'
  \ }))

  function! s:sort_buffers(...)
    let [b1, b2] = map(copy(a:000), 'get(g:fzf#vim#buffers, v:val, v:val)')
    " Using minus between a float and a number in a sort function causes an error
    return b1 < b2 ? 1 : -1
  endfunction

  function! s:buflisted()
    return filter(range(1, bufnr('$')), 'buflisted(v:val) && getbufvar(v:val, "&filetype") != "qf"')
  endfunction

  function! s:buflisted_sorted()
    return sort(s:buflisted(), 's:sort_buffers')
  endfunction

  function! s:all_files()
    return fzf#vim#_uniq(map(
      \ filter([expand('%')], 'len(v:val)')
      \   + filter(map(s:buflisted_sorted(), 'bufname(v:val)'), 'len(v:val)')
      \   + filter(copy(v:oldfiles), "filereadable(fnamemodify(v:val, ':p'))"),
      \ 'fnamemodify(v:val, ":~:.")'))
  endfunction

  command! FZFMru call fzf#run({
  \   'source':  s:all_files(),
  \   'sink*':    function('<sid>common_handler'),
  \   'options': '-m -x --reverse --expect=enter,ctrl-s,ctrl-v,ctrl-n',
  \   'down':    '50%'
  \ })

  function! s:ag_to_qf(line)
    let parts = split(a:line, ':')
    return {'filename': parts[0], 'lnum': parts[1], 'col': parts[2],
          \ 'text': join(parts[3:], ':')}
  endfunction

  function! s:ag_handler(lines)
    if len(a:lines) < 2 | return | endif

    let cmd = get({
      \ 'ctrl-s': 'split',
      \ 'ctrl-v': 'vertical split',
      \ 'ctrl-n': 'tabe'
    \ }, a:lines[0], 'e')

    let list = map(a:lines[1:], 's:ag_to_qf(v:val)')

    if a:lines[0] == 'ctrl-n'
      let first = list[0]
      execute cmd escape(first.filename, ' %#\')
      execute first.lnum
      execute 'normal!' first.col.'|zz'

      if len(list) > 1
        call setqflist(list)
        copen
        wincmd p
      endif
    else
      for file in list
        execute cmd file.filename
        execute file.lnum
        execute 'normal!' file.col.'|zz'
      endfor
    endif
  endfunction

  command! -nargs=* Agg call fzf#run({
  \   'source':  printf('ag --column --color "%s"',
  \                     escape(empty(<q-args>) ? '^(?=.)' : <q-args>, '"\')),
  \   'sink*':    function('<sid>ag_handler'),
  \   'options': '--ansi --expect=ctrl-s,ctrl-v,ctrl-n '.
  \              '-m -x --reverse '.
  \              '--bind=ctrl-a:select-all,ctrl-d:deselect-all',
  \   'down':    '50%'
  \ })

  command! -nargs=* Agk call fzf#run({
  \   'source':  printf('ag --column --color "%s"',
  \                     escape(empty(<q-args>) ? '^(?=.)' : <q-args>, '"\')),
  \   'sink*':    function('<sid>ag_handler'),
  \   'options': '--ansi --expect=ctrl-s,ctrl-v,ctrl-n '.
  \              '--delimiter : --nth 4.. '.
  \              '-m -x --reverse '.
  \              '--bind=ctrl-a:select-all,ctrl-d:deselect-all',
  \   'down':    '50%'
  \ })

  command! -nargs=* Agc call fzf#run({
  \   'source':  printf('ag --column --color "%s"',
  \                     escape(empty(<q-args>) ? expand('<cword>') : <q-args>, '"\')),
  \   'sink*':    function('<sid>ag_handler'),
  \   'options': '--ansi --expect=ctrl-s,ctrl-v,ctrl-n '.
  \              '-m -x --reverse '.
  \              '--bind=ctrl-a:select-all,ctrl-d:deselect-all',
  \   'down':    '50%'
  \ })
'''

[[plugins]]
repo = 'scrooloose/nerdtree'
hook_add = '''
  nnoremap <leader>f :NERDTreeFind<CR>
  nnoremap <leader>fg :NERDTreeVCS<CR>

  let g:NERDTreeWinSize = 70
  let g:NERDTreeMinimalUI = 1
  let g:NERDTreeShowHidden = 1
  let g:NERDTreeAutoDeleteBuffer = 1
  let g:NERDTreeCustomOpenArgs = {'file':{'where': 'v'}}
'''

[[plugins]]
repo = 'ajh17/VimCompletesMe'
hook_add = '''
  autocmd FileType vim let b:vcm_tab_complete = 'vim'
'''

[[plugins]]
repo = 'kana/vim-textobj-user'
[[plugins]]
repo = 'kana/vim-textobj-line'
[[plugins]]
repo = 'lucapette/vim-textobj-underscore'
[[plugins]]
repo = 'kana/vim-textobj-entire'
# [[plugins]]
# repo = 'rhysd/vim-textobj-ruby'
[[plugins]]
repo = 'rhysd/textobj-word-column.vim'
[[plugins]]
repo = 'jwhitley/vim-matchit'
[[plugins]]
repo = 'tpope/vim-surround'
[[plugins]]
repo = 'tpope/vim-endwise'
[[plugins]]
# let g:loaded_matchparen = 1
repo = 'itchyny/vim-parenmatch'
[[plugins]]
repo = 'itchyny/vim-cursorword'


[[plugins]]
repo = 'kana/vim-operator-user.git'

[[plugins]]
repo = 'kana/vim-operator-replace.git'
hook_add = '''
  map R <Plug>(operator-replace)
'''

[[plugins]]
repo = 'tyru/operator-camelize.vim'
hook_add = '''
  map <leader>c <plug>(operator-camelize-toggle)
'''

[[plugins]]
repo = 'osyo-manga/vim-anzu'
hook_add = '''
  nmap n <Plug>(anzu-n-with-echo)
  nmap N <Plug>(anzu-N-with-echo)
  nmap * <Plug>(anzu-star)
  nmap # <Plug>(anzu-sharp)
'''


[[plugins]]
repo = 'tpope/vim-fugitive'
hook_add = '''
  nmap gs :Gstatus<CR>
  nmap gb :Gblame<CR>
  nmap gd :Gdiff<CR>

  autocmd FileType fugitiveblame call s:fugitiveblame_my_settings()
  function! s:fugitiveblame_my_settings() abort
    nnoremap <silent> <C-p> :<C-u>!hub openpr <cword><CR>
  endfunction
'''
[[plugins]]
repo = 'tpope/vim-rhubarb'

[[plugins]]
repo = 'cohama/agit.vim'
hook_add = '''
  let g:agit_preset_views = {
  \ 'default': [
  \   {'name': 'log'},
  \   {'name': 'stat',
  \    'layout': 'botright vnew'},
  \   {'name': 'diff',
  \    'layout': 'belowright {winheight(".") * 3 / 4}new'}
  \ ],
  \ 'file': [
  \   {'name': 'filelog'},
  \   {'name': 'stat',
  \    'layout': 'botright vnew'},
  \   {'name': 'diff',
  \    'layout': 'belowright {winheight(".") * 3 / 4}new'}
  \ ]}

  nnoremap <silent> ,gaa :<C-u>Agit<CR>
  nnoremap <silent> ,ga :<C-u>AgitFile<CR>
'''
#
# [[plugins]]
# repo = 'powerman/vim-plugin-AnsiEsc'

[[plugins]]
repo = 'w0rp/ale'
hook_add = '''
  let g:prettier#config#print_width = 140
  let g:prettier#config#arrow_parens = 'always'
  let g:ale_completion_enabled = 1
  let g:ale_linters = {
        \ 'html': ['htmlhint'],
        \ 'css': ['stylelint'],
        \ 'javascript': ['eslint']
        \ }
'''


[[plugins]]
repo = 'jimsei/winresizer'
[[plugins]]
repo = 'nathanaelkane/vim-indent-guides'
[[plugins]]
repo = 'LeafCage/yankround.vim'
hook_add = '''
  nmap p <Plug>(yankround-p)
  xmap p <Plug>(yankround-p)
  nmap P <Plug>(yankround-P)
  nmap gp <Plug>(yankround-gp)
  xmap gp <Plug>(yankround-gp)
  nmap gP <Plug>(yankround-gP)
  nmap <C-p> <Plug>(yankround-prev)
  nmap <C-n> <Plug>(yankround-next)
'''

# [[plugins]]
# repo = 'tomtom/tcomment_vim'
[[plugins]]
repo = 'tyru/caw.vim'

[[plugins]]
repo = 'bkad/CamelCaseMotion'


[[plugins]]
repo = 'kana/vim-fakeclip'

[[plugins]]
repo = 'h1mesuke/vim-alignta'
[[plugins]]
repo = 'godlygeek/tabular'


[[plugins]]
repo = 'Shougo/context_filetype.vim'
hook_add = '''
  if !exists('g:context_filetype#same_filetypes')
    let g:context_filetype#same_filetypes = {}
  endif
  let g:context_filetype#same_filetypes.slim   = 'javascript, ruby'
  let g:context_filetype#same_filetypes.yaml   = 'ruby'
  let g:context_filetype#same_filetypes.scss   = 'css, slim, coffee, ruby'
  let g:context_filetype#same_filetypes.sass   = 'css, slim, coffee, ruby'
  let g:context_filetype#same_filetypes.es6   = 'javascript'
  let g:context_filetype#same_filetypes.coffee = 'javascript'
  " In gitconfig buffers, completes from all buffers.
  let g:context_filetype#same_filetypes.gitconfig = '_'
  " In default, completes from all buffers.
  let g:context_filetype#same_filetypes._ = '_'

  let g:context_filetype#filetypes = {
  \ 'slim' : [
  \   {
  \    'start' : '^\s*-',
  \    'end' : '$', 'filetype' : 'ruby',
  \   },
  \   {
  \    'start' : '^\s*\w*=',
  \    'end' : '$', 'filetype' : 'ruby',
  \   },
  \   {
  \    'start' : '^\s*ruby:',
  \    'end' : '^\S', 'filetype' : 'ruby',
  \   },
  \ ],
  \ 'toml' : [
  \   {
  \    'start' : '^hook_add = ',
  \    'end' : '$', 'filetype' : 'vim',
  \   },
  \ ],
  \ 'vue' : [
  \   {
  \    'start' : '^<script type=''ts''>',
  \    'end' : '$', 'filetype' : 'typescript',
  \   },
  \ ]
  \}
'''

[[plugins]]
repo = 'shougo/neosnippet.vim'
depends = ['context_filetype.vim']
hook_add = '''
  imap <silent><c-k>     <plug>(neosnippet_jump_or_expand)
  smap <silent><c-k>     <plug>(neosnippet_jump_or_expand)
  xmap <silent><c-k>     <plug>(neosnippet_expand_target)

  let g:neosnippet#enable_snipmate_compatibility = 1
  let g:neosnippet#enable_completed_snippet = 1
  let g:neosnippet#expand_word_boundary = 1
  let g:neosnippet#snippets_directory = '~/.vim/snippets'
'''

[[plugins]]
repo = 'shougo/neosnippet-snippets'

[[plugins]]
repo = 'vim-scripts/ruby-matchit'

[[plugins]]
repo = 'vim-ruby/vim-ruby'
hook_add = '''
  " let g:rubycomplete_rails                = 1
  " let g:rubycomplete_buffer_loading       = 1
  " let g:rubycomplete_classes_in_global    = 1
  " let g:rubycomplete_include_object       = 1
  " let g:rubycomplete_include_object_space = 1
'''

[[plugins]]
repo = 'tpope/vim-rails'

[[plugins]]
repo = 'slim-template/vim-slim'

[[plugins]]
repo = 'cakebaker/scss-syntax.vim'

# HTML5 + inline SVG omnicomplete function, indent and syntax for Vim
[[plugins]]
repo = 'othree/html5.vim'

# CSS3 syntax (and syntax defined in some foreign specifications) support for Vim’s built-in syntax/css.vim
[[plugins]]
repo = 'hail2u/vim-css3-syntax'


# This is a Vim plugin that provides Tern-based JavaScript editing support.
[[plugins]]
repo = 'ternjs/tern_for_vim'

# Yet Another JavaScript Syntax for Vim
[[plugins]]
repo = 'othree/yajs.vim'

# Vim indenter for standalone and embedded JavaScript and TypeScript.
[[plugins]]
repo = 'jason0x43/vim-js-indent'

[[plugins]]
repo = 'othree/es.next.syntax.vim'

# # Yet Another TypeScript Syntax
# [[plugins]]
# repo = 'HerringtonDarkholme/yats.vim'

# Typescript syntax files for Vim
[[plugins]]
repo = 'leafgarland/typescript-vim'

# Typescript tooling for Neovim
# [[plugins]]
# repo = 'mhartington/nvim-typescript'
# build = './install.sh'

# CoffeeScript support for vim
[[plugins]]
repo = 'kchmck/vim-coffee-script'

[[plugins]]
repo = 'posva/vim-vue'

# Syntax for JavaScript libraries
[[plugins]]
repo = 'othree/javascript-libraries-syntax.vim'
hook_add = '''
  let b:javascript_lib_use_jquery = 1
  let b:javascript_lib_use_underscore = 1
'''

# quickly format javascript, html and css files
# [[plugins]]
# repo = 'maksimr/vim-jsbeautify'
# hook_add = '''
#   " for JS
#   autocmd FileType javascript noremap <buffer>  <C-b> :call JsBeautify()<CR>
#   autocmd FileType javascript vnoremap <buffer>  <C-b> :call RangeJsBeautify()<CR>
#   " for json
#   autocmd FileType json noremap <buffer> <C-b> :call JsonBeautify()<CR>
#   autocmd FileType json vnoremap <buffer> <C-b> :call RangeJsonBeautify()<CR>
#   " for jsx
#   autocmd FileType jsx noremap <buffer> <C-b> :call JsxBeautify()<CR>
#   autocmd FileType jsx vnoremap <buffer> <C-b> :call RangeJsxBeautify()<CR>
#   " for html
#   autocmd FileType html noremap <buffer> <C-b> :call HtmlBeautify()<CR>
#   autocmd FileType html vnoremap <buffer> <C-b> :call RangeHtmlBeautify()<CR>
#   " for css or scss
#   autocmd FileType css noremap <buffer> <C-b> :call CSSBeautify()<CR>
#   autocmd FileType css vnoremap <buffer> <C-b> :call RangeCSSBeautify()<CR>
# '''

# colorize all text in the form #rgb, #rgba, #rrggbb, #rrgbbaa, rgb(...), rgba(...)
# [[plugins]]
# repo = 'lilydjwg/colorizer'
